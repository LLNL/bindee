// Generated by bindee 2.1 from enum.hh.
#ifndef BIND_ENUM_HH
#define BIND_ENUM_HH

#include <pybind11/pybind11.h>
namespace py = pybind11;

@INCLUDES@

// Records.

template <typename Target>
void bind_Private(Target &target);
template <typename Target>
void bind__(Target &target);
template <typename Target>
void bind__nontemplated(Target &target);
template <typename T, typename Target>
void bind_templated(Target &target, const std::string &classPrefix);
template <typename Target>
void bind_x(Target &target);

// Enums.

template <typename Target>
void bind_A(Target &target);
template <typename Target>
void bind_B(Target &target);
template <typename Target>
void bind_C_0(Target &target);
template <typename Target>
void bind_D_0(Target &target);
template <typename T, typename Target>
void bind_C_1(Target &target);
template <typename T, typename Target>
void bind_D_1(Target &target);
template <typename Target>
void bind_Forward_0(Target &target);
template <typename Target>
void bind_Forward_1(Target &target);
template <typename T, typename Target>
void bind_Forward_2(Target &target);
template <typename Target>
void bind_lower_0(Target &target);
template <typename Target>
void bind_lower_1(Target &target);

// Bind functions.

template <typename Target>
void bind_Private(Target &target) {
    using Class = Private;

    std::string className = "Private";
    std::string docString = @DOC_STRING@;

    py::class_<Class> bindee(target, className.c_str(), docString.c_str());
}

template <typename Target>
void bind__(Target &target) {
    using Class = _;

    std::string className = "_";
    std::string docString = @DOC_STRING@;

    py::class_<Class> bindee(target, className.c_str(), docString.c_str());
}

template <typename Target>
void bind__nontemplated(Target &target) {
    using Class = _nontemplated;

    std::string className = "_nontemplated";
    std::string docString = @DOC_STRING@;

    py::class_<Class> bindee(target, className.c_str(), docString.c_str());
    bindee.def("bar", (Class::C (Class::*)(Class::D)) &Class::bar);
}

template <typename T, typename Target>
void bind_templated(Target &target, const std::string &classPrefix) {
    using Class = templated<T>;

    std::string className = classPrefix + "templated";
    std::string docString = @DOC_STRING@;

    py::class_<Class> bindee(target, className.c_str(), docString.c_str());
    bindee.def("bar", (typename Class::D (Class::*)(typename Class::C)) &Class::bar, py::arg("c"));
}

template <typename Target>
void bind_x(Target &target) {
    using Class = x;

    std::string className = "x";
    std::string docString = @DOC_STRING@;

    py::class_<Class> bindee(target, className.c_str(), docString.c_str());
}

template <typename Target>
void bind_A(Target &target) {
    using Enum = A;

    std::string enumName = "A";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("AA", Enum::AA);
    bindee.export_values();

}

template <typename Target>
void bind_B(Target &target) {
    using Enum = B;

    std::string enumName = "B";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("BA", Enum::BA);
    bindee.value("BB", Enum::BB);

}

template <typename Target>
void bind_C_0(Target &target) {
    using Enum = _nontemplated::C;

    std::string enumName = "C";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("_ntCA", Enum::_ntCA);
    bindee.export_values();

}

template <typename Target>
void bind_D_0(Target &target) {
    using Enum = _nontemplated::D;

    std::string enumName = "D";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("_ntDA", Enum::_ntDA);
    bindee.value("_ntDB", Enum::_ntDB);

}

template <typename T, typename Target>
void bind_C_1(Target &target) {
    using Enum = typename templated<T>::C;

    std::string enumName = "C";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("tCA", Enum::tCA);
    bindee.export_values();

}

template <typename T, typename Target>
void bind_D_1(Target &target) {
    using Enum = typename templated<T>::D;

    std::string enumName = "D";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("tDA", Enum::tDA);
    bindee.value("tDB", Enum::tDB);

}

template <typename Target>
void bind_Forward_0(Target &target) {
    using Enum = Forward;

    std::string enumName = "Forward";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("FA", Enum::FA);

}

template <typename Target>
void bind_Forward_1(Target &target) {
    using Enum = _nontemplated::Forward;

    std::string enumName = "Forward";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("NTFA", Enum::NTFA);

}

template <typename T, typename Target>
void bind_Forward_2(Target &target) {
    using Enum = typename templated<T>::Forward;

    std::string enumName = "Forward";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("TFA", Enum::TFA);

}

template <typename Target>
void bind_lower_0(Target &target) {
    using Enum = x::lower;

    std::string enumName = "lower";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("xa", Enum::xa);
    bindee.export_values();

}

template <typename Target>
void bind_lower_1(Target &target) {
    using Enum = _::lower;

    std::string enumName = "lower";
    std::string docString = @DOC_STRING@;

    py::enum_<Enum> bindee(target, enumName.c_str(), docString.c_str());
    bindee.value("_a", Enum::_a);

}

void bind_enum_globals(py::module &bindee) {
    bindee.def("foo", (_nontemplated::D (*)(_nontemplated::C)) &foo);
    bindee.def("foo", (typename templated<@T0@>::C (*)(typename templated<@T0@>::D)) &foo<@T0@>, py::arg("d"));
}

#endif // BIND_ENUM_HH
